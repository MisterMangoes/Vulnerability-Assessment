/*
Program description: In this program, data is allocated memory for 30 64-bit integers. Then 50 64-bit integers are copied from source, which is a 64-bit integer array filled with 100 0's, to data using memmove() and the first element of data is printed out

Vulnerability and consequence: However, the storage size for data is only for 30 64-bit integers, but 50 64-bit integers are copied from source into data. Therefore, adjacent memory is overwritten and a stack buffer overflow would occur when source is copied to data

The vulnerability triggers in the following lines:
memmove(data, source, bytesToCopy);

Mitigation: To make this program safe to run, ensure that the storage size of data is equal to or greater than the number of bytes that are copied from source to data so that the function does not overwrite adjacent memory
*/

#include <inttypes.h>
#include <assert.h>

#define ALLOCA alloca

int main() {
	int64_t * data;
	int dataMemorySize = 30 * sizeof(int64_t);
	int64_t * dataBadBuffer = (int64_t *)ALLOCA(dataMemorySize);
	data = dataBadBuffer;
	int64_t source[100] = {0};
	int bytesToCopy = 50 * sizeof(int64_t);
	assert(dataMemorySize >= bytesToCopy);
	memmove(data, source, bytesToCopy);
	printf("%" PRId64 "\n", data[0]);
	return 0;
}