//CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_82

#include <cstdio>
#include <cwchar>
#include <cassert>
#include <alloca.h>

#define ALLOCA alloca
#define SNPRINTF swprintf

int dataArraySize = 50;

class CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_82_base
{
public:
    /* pure virtual function */
    virtual void action(wchar_t * data) = 0;
};

class CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_82_bad : public CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_82_base
{
public:
    void action(wchar_t * data);
};

void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_82_bad::action(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        assert(dataArraySize >= sizeof(source)/sizeof(source[0]));
        SNPRINTF(data, 100, L"%s", source);
        wprintf(L"%ls\n", data);
    }
}

int main()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    /* FLAW: Set a pointer to a "small" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a "large" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_82_base* baseObject = new CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_82_bad;
    baseObject->action(data);
    delete baseObject;
    printf("%s\n", "finished");
    return 0;
}