/*
Program description: In this program, a binary tree is created. A struct node contains the data for the node and a pointer to the left and right node, and the function createNode(), allocates memory for the struct node and returns the pointer to that memory location, called p. In the main function, a root node is created and the left/right child of the root node is created

Vulnerability and consequence: However, when allocating space for the memory location that the p points to, it only allocates enough memory for a pointer to the struct node, not the struct node itself. Therefore, only 8 bytes is allocated for p (when executed on a 64 bit processor) instead of 24 bytes, which causes a heap buffer overflow when addresses for the left and right nodes are assigned to the root node

The vulnerability triggers in the following lines:
root->left = createNode(b);

Mitigation: To make this program safe to run, ensure that there is enough memory allocated to p by ensuring that sizeof() uses the struct node itself instead of the pointer to the struct node. Use sizeof(struct node) instead of sizeof(struct node*)
*/

#include <assert.h>

struct node {
	int data;
	struct node * left;
	struct node * right;
};

struct node* createNode(int num) {
	int pMemorySize = sizeof(struct node*);
	struct node * p = malloc(pMemorySize);
	assert(pMemorySize >= sizeof(struct node));
	struct node ** p_1 = &p; 
	(**p_1).data = num;
	return p;
}

int main() {
	struct node * root = createNode(10);
	struct node ** root_1 = &root;
	(**root_1).left = createNode(5); 
	(**root_1).right = createNode(7); 
	return 0;
}