/*
Program description: In this program, data is allocated memory for 20 characters. Then, data is passed as an argument for the function, badSink_a(), which calls another function, badSink_b(), and passes data as an argument. Within badSink_b(), source is declared as a character array with size 60 and is filled with F's using memset(). The last element for source is assigned as a null terminate and source is copied data using strcpy(). Finally, data is printed out 

Vulnerability and consequence: However, data has space allocated for 20 characters but the storage size for source is 60 characters. Therefore, copying source to data with strcpy() will overwrite adjacent memory and will result in a heap buffer overflow

The vulnerability triggers in the following lines:
strcpy(data, source);

Mitigation: To make this program safe to run, ensure that the storage size of data is equal to or larger than the storage size of source to avoid overwriting adjacent memory
*/

#include <assert.h>

int dataMemorySize = 20 * sizeof(char);

void badSink_b(char * data) {
	char source[60];
	memset(source, 'F', 60-1);
	char * source_1 = &source[60-1];
	*source_1 = '\0';
	assert(dataMemorySize >= sizeof(source));
	strcpy(data, source);
	printf("%s\n", data);
	free(data);
}

void badSink_a(char * data) {
	badSink_b(data);
}

int main() {
	char * data = (char *)malloc(dataMemorySize);
	char * data_1 = &data[0];
	*data_1 = '\0';
	badSink_a(data);
	return 0;
}