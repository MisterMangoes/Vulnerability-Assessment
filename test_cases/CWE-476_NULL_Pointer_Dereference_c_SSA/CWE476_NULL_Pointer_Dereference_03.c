/*
Program description: In this program, the struct structCharVoid contains two variables, structCharVoid->charFirst and structCharVoid->voidSecond. structCharVoid is allocated memory and strings are assigned to structCharVoid->charFirst and structCharVoid->voidSecond. Then, structCharVoid is set to NULL and structCharVoid->charFirst and structCharVoid->voidSecond is printed out

Vulnerability and consequence: However, after structCharVoid is set to NULL, it is dereferenced to print out structCharVoid->charFirst and structCharVoid->voidSecond. Therefore, a NULL pointer dereference occurs

The vulnerability triggers in the following lines:
printf("%s\n", (char *)structCharVoid->charFirst);

Mitigation: To make this program safe to run, ensure that structCharVoid is not set to NULL if there are more uses. Perform a NULL check to ensure that structCharVoid is not NULL
*/

#include <stdlib.h>
#include <assert.h>

static const int STATIC_CONST_TRUE = 1;

typedef struct _charVoid {
	char charFirst[4];
	void * voidSecond;
} charVoid;

int main() {
	if(STATIC_CONST_TRUE) {
		charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
		charVoid ** structCharVoid_1 = &structCharVoid; 
		(**structCharVoid_1).voidSecond = (void *)"abc";
		memcpy(structCharVoid->charFirst, "efg", 3);
		(**structCharVoid_1).charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0';
		*structCharVoid_1 = NULL;
		assert(structCharVoid != NULL);
		printf("%s\n", (char *)structCharVoid->charFirst);
		printf("%s\n", (char *)structCharVoid->voidSecond);
		free(structCharVoid);
	}
	return 0;
}