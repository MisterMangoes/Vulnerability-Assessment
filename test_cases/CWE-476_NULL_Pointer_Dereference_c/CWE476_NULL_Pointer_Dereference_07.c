/*
Program description: In this program, a string stored in inputString and an integer size (which is assigned a value from standard input using fgets()) is passed into the function f(). Within f(), size is used as the size of the memory block allocation for the character pointer, c_str, then inputString is copied to c_str using memcpy(), and c_str is freed

Vulnerability and consequence: However, if malloc() fails e.g. because size is negative or there is insufficient memory, c_str is set to NULL. Therefore, a NULL pointer dereference occurs when the inputString is copied to c_str using memcpy()

The vulnerability triggers in the following lines:
memcpy(c_str, input_str, size);

Mitigation: To make this program safe to run, ensure that c_str is not set to NULL after malloc() by performing a NULL check. Use an if statement to ensure that the value of size is a suitable memory block size for malloc()
*/

#include <stdio.h>
#include <assert.h> 

void f(char * input_str, int size) {
	char * c_str = (char *)malloc(size);
	assert(c_str != NULL);
	memcpy(c_str, input_str, size);
	free(c_str);
	c_str = NULL;
}

int main() {
	char inputString[16] = "Hello";
	char inputBuffer[100] = "";
	int size = 1;
	if (fgets(inputBuffer, 100, stdin) != NULL) {
		size = atoi(inputBuffer);
	}
	f(inputString, size);
	return 0;
}   