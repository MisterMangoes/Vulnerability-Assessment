/*
Program description: In this program, a double pointer, data, is passed as an argument to the function, badSource(). In this function, within an if statement, data is allocated memory with the size of data and the memory location pointed to by data is assigned to a double, 1.7E300

Vulnerability and consequence: However, the memory allocated for data is the size of a pointer, which depends on multiple factors, including operating system and CPU architecture. The storage size of a double is 8 bytes, but a pointer could be less than that. Therefore, when the memory location pointed to by data is assigned to a double, it could overwrite adjacent memory and cause a heap buffer overflow

The vulnerability triggers in the following lines:
*data = 1.7E300;

Mitigation: To make this program safe to run, ensure that the storage size of data is equal to or larger than the storage size of a double to avoid overwriting adjacent memory. Use sizeof(double), which is the data type, instead of sizeof(data), which is only the pointer to a double
*/

#include <stdlib.h>
#include <assert.h>

static int badStatic = 0;

static double * badSource(double * data) {
	if(badStatic) {
		int dataMemorySize = sizeof(data);
		data = (double *)malloc(dataMemorySize);
		assert(dataMemorySize >= sizeof(double));
		*data = 1.7E300;
	}
	return data;
}

int main() {
	double * data = NULL;
	badStatic = 1;
	data = badSource(data);
	printf("%g\n", *data);
	free(data);
	return 0;
}