/*
Program description: In this program, data is allocated with space for 50 twoIntsStruct's. Then, a twoIntsStruct array, source, is declared with a size of 100 and the integers within source are assigned as 0 using a for loop. Using another for loop, source is copied to data and the integers within the first struct element are printed out after the copy

Vulnerability and consequence: However, the storage size for data is only for 50 twoIntStruct's, but source contains 100 twoIntStructs. Therefore, the program would overwrite adjacent memory and a heap buffer overflow would occur when source is copied to data

The vulnerability triggers in the following lines:
for (i = 0; i < 100; i++)
{
	data[i] = source[i];
}

Mitigation: To make this program safe to run, ensure that the storage size of data is equal to or greater than the storage size of source so that the copy from source to data does not overwrite adjacent memory
*/

#include <assert.h>

typedef struct _twoIntsStruct {
	int intOne;
	int intTwo;
} twoIntsStruct;

int main() {
	twoIntsStruct * data;
	twoIntsStruct ** dataPtr1 = &data;
	twoIntsStruct ** dataPtr2 = &data;
	int dataMemorySize = 50 * sizeof(twoIntsStruct);
	data = (twoIntsStruct *)malloc(dataMemorySize);
	*dataPtr1 = data;
	data = *dataPtr2;
	twoIntsStruct source[100];
	for (int i = 0; i < 100; i++) {
		source[i].intOne = 0;
		source[i].intTwo = 0;
	}
	assert(dataMemorySize/sizeof(twoIntsStruct) >= 100);
	for (int i = 0; i < 100; i++) {
		data[i] = source[i];
	}
	printf("%d -- %d\n", (&data[0])->intOne, (&data[0])->intTwo);
	free(data);
	return 0;
}