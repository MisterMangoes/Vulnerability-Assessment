/*
Program description: In this program, a number of bytes equal to the storage size of *structCharVoid from SRC_STR is copied to structCharVoid->charFirst using memcpy(). The last character in structCharVoid->charFirst is assigned to a null terminator after the copy from SRC_STR and the strings structCharVoid->charFirst and structCharVoid->voidSecond is printed out

Vulnerability and consequence: However, the storage size size of *structCharVoid is 24 bytes and the storage size of structCharVoid.charFirst is only 16 bytes. Therefore, when SRC_STR is copied to structCharVoid->charFirst, part of the struct is overwritten incorrectly, thus causing a heap buffer overflow

The vulnerability triggers in the following lines:
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));

Mitigation: To make this program safe to run, ensure that the number of bytes copied from SRC_STR is equal to or lower than the storage size of *structCharVoid.charFirst to avoid overwriting adjacent memory. Use sizeof(structCharVoid->charFirst) instead of sizeof(*structCharVoid)
*/

#include <assert.h>

#define SRC_STR "0123456789abcdef0123456789abcde" //32 characters

typedef struct _charVoid {
	char charFirst[16];
	void * voidSecond;
} charVoid;

int main() {
	charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
	structCharVoid->voidSecond = (void *)SRC_STR;
	int bytesToCopy = sizeof(*structCharVoid);
	assert(sizeof(structCharVoid->charFirst) >= bytesToCopy);
	memcpy(structCharVoid->charFirst, SRC_STR, bytesToCopy);
	structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char)) - 1] = '\0';
	printf("%s\n", (char *)structCharVoid->charFirst);
	printf("%s\n", (char *)structCharVoid->voidSecond);
	free(structCharVoid);
	return 0;
}