/*
Program description: In this program, a character array of size 8, inputBuffer, is assigned a string of up to 8 characters which is obtained through standard input using fgets() and is passed as an argument to the function copy_input(). In this function, any & character in inputBuffer is encoded to &amp;, and the encoded string is stored in dst_buf. dst_buf is printed out and is returned from the copy_input function 

Vulnerability and consequence: However, this program assumes that the encoding expansion will only expand a & character by a factor of 4 (the memory space allocated for the dst_buf is 4 * sizeof(char) * max_input_length) but each & character is expanded by a factor of 5 (& becomes &amp;, which is 5 characters). Therefore, if there are multiple &'s, the string will expand past the allocated memory space for dst_buf and cause a heap buffer overflow

The vulnerability triggers in the following lines:
for (i = 0; i < strlen(user_supplied_string) + 1; i++){
		if('&' == user_supplied_string[i]){
			dst_buf[dst_index++] = '&';
			dst_buf[dst_index++] = 'a';
			dst_buf[dst_index++] = 'm';
			dst_buf[dst_index++] = 'p';
			dst_buf[dst_index++] = ';';
		}
		else dst_buf[dst_index++] = user_supplied_string[i];
	}
}

Mitigation: To make this program safe to run, ensure that the storage size of dst_buf is greater than or equal to 5 * sizeof(char) * maximum input length (i.e. assume that each character can expand by a factor of 5) to avoid overwriting adjacent memory
*/

#include <stdio.h>
#include <assert.h>

char * copy_input(char *user_supplied_string) {
	int dst_index = 0;
	int max_input_length = 8;
	int destMemorySize = 4 * sizeof(char) * max_input_length;
	char *dst_buf = (char*)malloc(destMemorySize);
	assert(destMemorySize >= 5 * sizeof(char) * max_input_length);
	for (int i = 0; i < strlen(user_supplied_string) + 1; i++){
		if('&' == user_supplied_string[i]) {
			dst_buf[dst_index++] = '&';
			dst_buf[dst_index++] = 'a';
			dst_buf[dst_index++] = 'm';
			dst_buf[dst_index++] = 'p';
			dst_buf[dst_index++] = ';';
		}
		else {
			dst_buf[dst_index++] = user_supplied_string[i];
		}
	}
	printf("%s\n", dst_buf);
	return dst_buf;
}

int main() {
	char inputBuffer[8];
	fgets(inputBuffer, 8, stdin);
	copy_input(inputBuffer);
	return 0;
}