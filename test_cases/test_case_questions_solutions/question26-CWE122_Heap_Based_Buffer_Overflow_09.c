/*
Program description: In this program, data is allocated memory for 20 characters. Then, data is passed as an argument for the function, badSink_a(), which calls another function, badSink_b(), and passes data as an argument. Within badSink_b(), source is declared as a character array with size 60 and is filled with F's using memset(). The last element for source is assigned as a null terminate and source is copied data using strcpy(). Finally, data is printed out 

Vulnerability and consequence: However, data has space allocated for 20 characters but the storage size for source is 60 characters. Therefore, copying source to data with strcpy() will overwrite adjacent memory and will result in a heap buffer overflow

The vulnerability triggers in the following lines:
strcpy(data, source);

Mitigation: To make this program safe to run, ensure that the storage size of data is equal to or larger than the storage size of source to avoid overwriting adjacent memory
*/

#include <assert.h>

int dataArraySize = 20;

void badSink_b(char * data) {
	int dataFreed = 0;
	char source[60];
	int bytesToCopy = 60-1;
	//assert(bytesToCopy <= sizeof(source)/sizeof(source[0]));
	memset(source, 'F', bytesToCopy);
	source[60-1] = '\0';
	//assert(dataArraySize >= sizeof(source)/sizeof(source[0]));
	strcpy(data, source);
	//assert(data != NULL);
	printf("%s\n", data);
	free(data);
	dataFreed = 1;
}

void badSink_a(char * data) {
	badSink_b(data);
}

int main() {
	char * data = (char *)malloc(dataArraySize * sizeof(char));
	//assert(data != NULL);
	data[0] = '\0';
	badSink_a(data);
	return 0;
}

//Original file: CWE122_Heap_Based_Buffer_Overflow_09

/*
Question: Which of the following is correct? D
a) To catch this bug, the assertion at line 25 should be added
b) To catch this bug, the assertion at line 37 should be added
c) To catch this bug, the assertion at line 20 should be added
d) To catch this bug, the assertion at line 23 should be added
*/