/*
Program description: In this program, the function globalReturnsTrueOrFalse() randomly returns either 0 or 1. If globalReturnsTrueOrFalse returns a 1, then data is assigned a value from standard input using fscanf(). Otherwise, data is assigned as 7. Then, buffer is allocated space for 15 integers, which are all assigned to 0 using a for loop. If data is equal or greater than 0, then the element at index data in buffer is assigned to 6 and the elements in buffer is printed out

Vulnerability and consequence: However, there is no check to see if the index data is out of bounds for the buffer array. If globalReturnsTrueOrFalse() returns a 1 and data is assigned an integer greater than 14 through user input, the index data will overrun the upper boundaries of buffer and overwrite adjacent memory, thus causing a heap buffer overflow

The vulnerability triggers in the following lines:
buffer[data] = 1;

Mitigation: To make this program safe to run, ensure that the index data will not exceed the upper bound of the buffer array. Use an if condition to check if the data is a suitable index for buffer and it will not overrun the upper bound of the array to avoid overwriting adjacent memory
*/

#include <stdio.h>
#include <assert.h>

int globalReturnsTrueOrFalse() {
	srand(time(0)); //use current time as seed
	return (rand() % 2);
}

int main() {
	int data = -1;
	if(globalReturnsTrueOrFalse()) {
		fscanf(stdin, "%d", &data);
	}
	else {
		data = 7;
	}
	printf("Data: %d\n", data);
	int bufferArraySize = 15;
	int * buffer = (int *)malloc(bufferArraySize * sizeof(int));
	for (int i = 0; i < bufferArraySize; i++) {
		buffer[i] = 0;
	}
	if (data >= 0) {
		assert(data < bufferArraySize);
		buffer[data] = 6;
		for(int i = 0; i < bufferArraySize; i++) {
			printf("%d\n", buffer[i]);
		}
	}
	else {
		printf("%s\n", "ERROR: Array index is negative.");
	}
	free(buffer);
	return 0;
}

//Original file: CWE122_Heap_Based_Buffer_Overflow_08

/*
Question: Which of the following is correct? B
a) A stack buffer overflow occurs in the for loop at line 31
b) A heap buffer overflow occurs at line 36
c) A null pointer derference occurs in the for loop at line 37
d) A heap buffer overflow occurs in the for loop at at line 37
*/