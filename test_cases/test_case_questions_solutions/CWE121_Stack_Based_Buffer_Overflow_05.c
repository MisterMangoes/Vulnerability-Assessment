/*
Program description: In this program, data is allocated memory for 10 bytes and the func1 function is called. In the func1 function, source is initialized as an array with 10 integers that is filled with 0â€™s. Then, data is copied to source using a for loop and the first element of data is printed out

Vulnerability and consequence: However, when allocating the memory for data, sizeof(int) is not used, so the storage size for data is only 10 bytes, not 10 integers. Therefore, a stack buffer overflow would occur when source is copied to data because it overruns the memory that has been allocated for data

The vulnerability triggers in the following lines:
for (i = 0; i < 10; i++) {
	data[i] = source[i];
}

Mitigation: To make this program safe to run, ensure that the memory space allocated for data is equal to or greater than the size of 10 integers (the number of integers in source). Use sizeof(int) when allocating memory for data
*/

#include <assert.h>

#define ALLOCA alloca

int dataMemorySize = 10;

void func1(int * data) {
	int source[10] = {0};
	assert(dataMemorySize >= 10 * sizeof(int));
	for (int i = 0; i < 10; i++) {
		data[i] = source[i];
	}
	printf("%d\n", data[0]);
}

int main() {
	int * data = (int *)ALLOCA(dataMemorySize);
	func1(data);
	return 0;
}

//Original file: CWE121_Stack_Based_Buffer_Overflow_05

/*
Question: Which of the following is correct? B
a) A stack buffer overflow occurs in the for loop at line 23 because the index overruns the boundary of the buffer
b) A stack buffer overflow occurs in the for loop at line 23 because sizeof() is not used when allocating memory
c) A heap buffer overflow occurs in the for loop at line 23 because the index overruns the boundary of the buffer
d) A heap buffer overflow occurs in the for loop at line 23 because sizeof() is not used when allocating memory
*/