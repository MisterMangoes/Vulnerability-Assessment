/*
Program description: In this program, source is copied onto data with memmove() with the inclusion of a terminating character and data is printed out

Vulnerability and consequence: However, the storage size for dataBadBuffer is equal to 10 characters, but source is equal to 11 characters (10 characters plus the terminating character), thus causing a stack buffer overflow when copied to dataBadBuffer

The vulnerability triggers in the following lines:
memmove(data, source, (strlen(source) + 1) * sizeof(char));

Mitigation: To make this program safe to run, ensure that dataBadBuffer can hold at least the number of characters in source and consider the addition of a terminating character from source when performing string copies (if there is a terminating character, storage size needs to be at least string length + 1)
*/

#include <stdio.h>
#include <assert.h>

#define ALLOCA alloca
#define SRC_STRING "AAAAAAAAAA" //10 characters

int main() {
	int dataArraySize = 10;
	char * data = NULL;
	data = (char *)ALLOCA(dataArraySize * sizeof(char));
	data[0] = '\0';
	char source[10 + 1] = SRC_STRING; //include terminating character
	assert(dataArraySize >= sizeof(source)/sizeof(source[0]));
	memmove(data, source, (strlen(source) + 1) * sizeof(char));
	printf("%s\n", data);
	return 0;
}

//Original file: CWE121_Stack_Based_Buffer_Overflow_03

/*
Question: Which of the following is correct? A
a) A stack buffer overflow occurs at line 25
b) A null pointer dereference occurs at line 26
c) A stack buffer overflow occurs at line 23
d) A use after free occurs at line 26
*/