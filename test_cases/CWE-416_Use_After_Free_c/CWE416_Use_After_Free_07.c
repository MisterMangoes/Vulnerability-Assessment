/*
Program description: In this program, four character pointers are allocated memory in the function assignBuffers(). Then, one of the pointers, buf2R1 is freed and a string is copied to the memory location that buf2R1 points to using strncpy(). Finally, the rest of the pointers are freed

Vulnerability and consequence: However, buf2R1 is freed and a string is copied to buf2R1 with strncpy() after the memory has been deallocated. Therefore, a use after free error occurs

The vulnerability triggers in the following lines:
strncpy(buf2R1, "aaaa", BUFSIZER1-1);

Mitigation: To make this program safe to run, ensure that buf2R1 is only freed after a string has been copied to it using strncpy(). Therefore, only free buf2R1 when there are no more uses for buf2R1. To check if buf2R1 has been freed or not, assign the pointer to NULL after using free, then perform a NULL check
*/

#include <assert.h>

#define BUFSIZER1 10
#define BUFSIZER2 ((BUFSIZER1/2))

char * buf1;
char * buf2;
char * buf3;

int buf1Freed = 0;
int buf2Freed = 0;
int buf3Freed = 0;

void assignBuffers() {
	buf1 = (char *) malloc(BUFSIZER1);
	buf2 = (char *) malloc(BUFSIZER1);
	free(buf2);
	buf2Freed = 1;
	buf3 = (char *) malloc(BUFSIZER2);
}

int main() {  
	assignBuffers();
	strncpy(buf1, "abcde12345", BUFSIZER1-1);
	assert(!buf2Freed);
	strncpy(buf2, "qwertyuiop", BUFSIZER1-1);
	strncpy(buf3, "abcde", BUFSIZER2-1);
	free(buf1);
	buf1Freed = 1;
	free(buf3);
	buf3Freed = 1;
	return 0;
}