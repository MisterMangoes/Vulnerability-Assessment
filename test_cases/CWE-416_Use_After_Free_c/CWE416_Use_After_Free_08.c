/*
Program description: In this program, the user can input their username if they use the "auth" command, which is stored in the auth struct. If they use the "login" command, the program checks if auth->name is equal to "myusername". If they are equal, then a success message is printed out, otherwise, an error message is printed out. The user can reset the username they entered with the "auth" command with the "reset" command, in which the pointer to the auth struct is freed

Vulnerability and consequence: However, if the user uses the "reset" command, then the pointer for the auth struct is freed. Therefore, when the user tries to login immediately after a reset, the program causes a use after free error because it tries to use auth->name after the pointer to the auth struct is already freed

The vulnerability triggers in the following lines:
printf("Username: %s\n", auth->name);

Mitigation: To make this program safe to run, ensure that auth is not freed when there could be more uses for auth (e.g. only free auth at the end of the while loop). To check if auth has been freed or not, assign the pointer to NULL after using free, then perform a NULL check
*/

#include <stdio.h>
#include <assert.h>

struct auth {
	char name[32];
};

struct auth *auth;

int main() {
	int authFreed = 0;
	char line[64];
	while(1) {
		printf("Enter command: ");
		if(fgets(line, sizeof(line), stdin) == NULL) break;
		if(strncmp(line, "auth ", 5) == 0) {
			auth = malloc(sizeof(auth));
			authFreed = 0;
			memset(auth, 0, sizeof(auth));
			if(strlen(line + 5) < 31) {
				strcpy(auth->name, line + 5);
			}
		}
		if(strncmp(line, "reset", 5) == 0) {
			free(auth);
			authFreed = 1;
		}
		if(strncmp(line, "login", 5) == 0) {
			assert(!authFreed);
			printf("Username: %s\n", auth->name);
			if(strncmp(auth->name, "myusername", 10) == 0) {
				printf("Login success\n");
			} 
			else {
				printf("Please enter correct username\n");
			}
		}
	}
	return 0;
}