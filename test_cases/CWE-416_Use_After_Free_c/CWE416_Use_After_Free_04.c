/*
Program description: In this program, memory is allocated for two integer pointers, p and q, and the memory location that is pointed by p and q is assigned as 10 and 20, respectively. Then, p is assigned to q (i.e. the pointers point to the same memory location), the integer at the memory location that p and q points to is printed out, and p and q is deallocated with free

Vulnerability and consequence: However, because p is assigned to q and therefore points to the same memory location, this means only the memory location for q is freed, not the memory location originally pointed by p. Therefore, after freeing p, freeing q causes a use after free error because the program attempts to free the same memory location twice

The vulnerability triggers in the following lines:
free(q);

Mitigation: To make this program safe to run, ensure that q is not already freed. To check if a pointer has been freed or not, assign the pointer to NULL after using free, then perform a NULL check. An additional flaw in this program is that p is never freed, which causes a memory leak
*/

#include <assert.h>

int main() {
	int pFreed = 0;
	int qFreed = 0;
	int * p = (int *)malloc(sizeof(int));
	int * q = (int *)malloc(sizeof(int));
	*p = 10;
	*q = 20;
	p = q;
	printf("%d %d\n", *p, *q);
	free(p);
	qFreed = 1;
	assert(!qFreed); 
	free(q);
	qFreed = 1;
	return 0;
}