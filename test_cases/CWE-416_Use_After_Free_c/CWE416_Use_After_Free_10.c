/*
Program description: In this program, a linked list is created. node1 is the first node in the linked list, which contains a pointer to the next node, node2. All nodes are freed by using the function free_list(). In this function, a for loop is used to traverse the linked list until the pointer to the next node is NULL to deallocate the memory for each node

Vulnerability and consequence: However, in the for loop to deallocate the memory for each node, the node p is freed before p->next is executed, thus causing a use after free error

The vulnerability triggers in the following lines:
for (p = head; p != NULL; p = p->next) {
	free(p);
}

Mitigation: To make this program safe to run, store a reference to p->next in another pointer before freeing p e.g. for (p = head; p != NULL; p = q) { q = p->next; free(p); }
*/

#include <stdlib.h>
#include <assert.h>

struct node {
	int value;
	struct node * next;
};

struct node * p;
int p_freed = 0;

void assert_p() {
	assert(!p_freed);
	p = p->next;
	p_freed = 0;
}
   
void free_list(struct node * head) {
	for (p = head; p != NULL; assert_p()) {
		free(p);
		p_freed = 1;
	}
}

int main() {
	struct node * node1 = malloc(sizeof(struct node));
	struct node * node2 = malloc(sizeof(struct node));
	node1->value = 5;
	node2->value = 9;
	node1->next = node2;
	node2->next = NULL;
	free_list(node1);
	return 0;
}