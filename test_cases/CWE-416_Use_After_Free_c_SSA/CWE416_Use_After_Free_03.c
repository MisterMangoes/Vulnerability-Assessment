/*
Program description: In this program, a string of 4 characters, inputBuffer is initialized. For each 'h' character in inputBuffer, it is exanded to "hello" and result of the string expansion is stored in the memory location pointed by the character pointer, dst_buf. The memory location pointed by dst_buf is freed and is printed out

Vulnerability and consequence: However, after dst_buf is deallocated with free, the program prints out the string that is stored in memory location pointed to by dst_buf, which causes a use after free error

The vulnerability triggers in the following lines:
printf("%s\n", dst_buf);

Mitigation: To make this program safe to run, ensure that dst_buf is only freed after it has been printed out. Therefore, only free dst_buf when there are no more uses for data. To check if the dst_buf has been freed or not, assign dst_buf to NULL after using free, then perform a NULL check
*/

#include <assert.h>

int main()  {
	int dst_bufFreed = 0;
	int * dst_bufFreed_1 = &dst_bufFreed;
	char inputBuffer[5] = {'h', 'h', 'h', 'i', '\0'};
	char * dst_buf = (char*)malloc(5 * sizeof(char) * strlen(inputBuffer));
	char * dst_buf_1 = &dst_buf[0];
	int dst_index = 0;
	int i = 0;
	int * i_1 = &i;
	for (*i_1 = 0; i < strlen(inputBuffer) + 1; *i_1 = i + 1) {
		if('h' == inputBuffer[i] ) {
			*(dst_buf_1 + dst_index++) = 'h';
			*(dst_buf_1 + dst_index++) = 'e';
			*(dst_buf_1 + dst_index++) = 'l';
			*(dst_buf_1 + dst_index++) = 'l';
			*(dst_buf_1 + dst_index++) = 'o';
		}
		else {
			*(dst_buf_1 + dst_index++) = inputBuffer[i];
		}
	}
	free(dst_buf);
	*dst_bufFreed_1 = 1;
	assert(!dst_bufFreed);
	printf("%s\n", dst_buf);
	return 0;
}