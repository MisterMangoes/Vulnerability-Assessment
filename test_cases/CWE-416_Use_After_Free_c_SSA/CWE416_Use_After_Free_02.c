/*
Program description: In this program, data is allocated memory for 10 characters and the string "Hello" is copied to the buffer using strcpy(). Then, the doubleFree() function is called and data is passed as an argument. Within doubleFree(), the memory that was allocated to data is reallocated using realloc() and if realloc() returns NULL, the original pointer, data, is freed. The new pointer after reallocation is returned from doubleFree()

Vulnerability and consequence: However, when using realloc(), the size of the new memory block is 0. When it is 0, the original pointer is deallocated and realloc() returns NULL. Therefore, within doubleFree(), when data is freed because the size of memory is 0, data is freed twice, which causes a use after free error

The vulnerability triggers in the following lines:
free(c_str1);

Mitigation: To make this program safe to run, ensure that c_str1 is only freed once. To check if the c_str1 has been freed or not, assign cstr_1 to NULL if the size for realloc() is 0
*/

#include <stdlib.h>
#include <assert.h>

char * doubleFree(char *c_str1, size_t size) {
	int c_str1Freed = 0;
	int * c_str1Freed_1 = &c_str1Freed;
	char * c_str2 = (char *)realloc(c_str1, size);
	if (c_str2 == NULL) {
		*c_str1Freed_1 = 1;
		assert(!c_str1Freed);
		free(c_str1);
	}
	return c_str2;
}

int main() {
	char * data = (char *)malloc(10 * sizeof(char));
	strcpy(data, "Hello");
	printf("String: %s\n", data);
	char * dataNew = doubleFree(data, 0);
	return 0;
}