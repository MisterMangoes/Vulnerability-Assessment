/*
Program description: In this program, a linked list is created. node1 is the first node in the linked list, which contains a pointer to the next node, node2. All nodes are freed by using the function free_list(). In this function, a for loop is used to traverse the linked list until the pointer to the next node is NULL to deallocate the memory for each node

Vulnerability and consequence: However, in the for loop to deallocate the memory for each node, the node p is freed before p->next is executed, thus causing a use after free error

The vulnerability triggers in the following lines:
for (p = head; p != NULL; p = p->next) {
	free(p);
}

Mitigation: To make this program safe to run, store a reference to p->next in another pointer before freeing p e.g. for (p = head; p != NULL; p = q) { q = p->next; free(p); }
*/

#include <stdlib.h>
#include <assert.h>

struct node {
	int value;
	struct node * next;
};

struct node * p;
struct node ** p_1 = &p;
int p_freed = 0;
int * p_freed_1 = &p_freed;

void assert_p() {
	assert(!p_freed);
	*p_1 = p->next; 
	*p_freed_1 = 0;
}

void free_list(struct node * head) {
	for (*p_1 = head; p != NULL; assert_p()) {
		free(p);
		*p_freed_1 = 1;
	}
}

int main() {
	struct node * node1 = malloc(sizeof(struct node));
	struct node * node2 = malloc(sizeof(struct node));
	struct node ** node1_1 = &node1;
	struct node ** node2_1 = &node2;
	(**node1_1).value = 5;
	(**node2_1).value = 9;
	(**node1_1).next = node2;
	(**node2_1).next = NULL;
	free_list(node1);
	return 0;
}