/*
Program description: In this program, the struct p_charStruct, is used to store two character pointers, p_charStruct->charFirst and p_charStruct->charSecond. which have memory allocated to store 16 characters each. The memory locations that p_charStruct->charFirst and p_charStruct->charSecond points to are assigned as "abcd" and "efgh" respectively,, then they are printed out. Finally, p_charStruct is freed and p_charStruct->charFirst and p_charStruct->charSecond are also freed

Vulnerability and consequence: However, after printing out the character pointers, the memory location for the p_charStruct is freed before freeing p_charStruct->charFirst and p_charStruct->charSecond. Therefore, when attempting to free the pointers in p_charStruct, a use after free error occurs

The vulnerability triggers in the following lines:
free(p_charStruct->charFirst);

Mitigation: To make this program safe to run, ensure that the pointers contained in p_charStruct are freed before freeing p_charStruct itself
*/

#include <assert.h>

typedef struct _charStruct {
	char * charFirst;
	char * charSecond;
} charStruct;

int main() {
	int charStructFreed = 0;
	int * charStructFreed_1 = &charStructFreed;
	int charFirstFreed = 0;
	int * charFirstFreed_1 = &charFirstFreed;
	int charSecondFreed = 0;
	int * charSecondFreed_1 = &charSecondFreed;
	charStruct * p_charStruct = (charStruct *)malloc(sizeof(charStruct));
	charStruct ** p_charStruct_1 = &p_charStruct;
	(**p_charStruct_1).charFirst = malloc(sizeof(char) * 16);
	(**p_charStruct_1).charSecond = malloc(sizeof(char) * 16);
	(**p_charStruct_1).charFirst = "abcd";
	(**p_charStruct_1).charSecond = "efgh";
	free(p_charStruct);
	*charStructFreed_1 = 1;
	assert(!charStructFreed);
	free(p_charStruct->charFirst);
	*charFirstFreed_1 = 1;
	free(p_charStruct->charSecond);
	*charSecondFreed_1 = 1;
	return 0;
}