/*
Program description: In this program, there are two declarations for the data variable: one in the outer block, and one in the inner block. However, only the data variable that was declared in the inner block is used and it is assigned as 10 by using a union. Then, buffer is initialized as an integer array of size 10 that is filled with 0's. The element at index data (the inner block data variable) in buffer is assigned as 5

Vulnerability and consequence: However, the index data exceeds the upper boundary of buffer because it was assigned as 10 by using a union. Therefore, when the element at index data in buffer is assigned to 5, it overwrites adjacent memory with 1 instead, thus causing a stack buffer overflow

Vulnerability triggers in the following lines:
buffer[data] = 5;

Mitigation: To make this program safe to run, ensure that the index data does not exceed the upper bound of the buffer array to avoid overwriting adjacent memory. Also, ensure that the correct variable scope is used; the inner block data variable is used instead of the outer block data variable
*/

#include <assert.h>

typedef union {
	int unionFirst;
	int unionSecond;
} unionType;

int main() {
	unionType myUnion;
	unionType * myUnion_1 = &myUnion;
	(*myUnion_1).unionFirst = 10;
	{
		int data = (*myUnion_1).unionSecond;
		{
			int buffer[10];
			memset(buffer, 0, 10 * sizeof(int));
			assert(data < sizeof(buffer)/sizeof(buffer[0]));
			int * buffer_1 = &buffer[data];
			*buffer_1 = 5;
			int i = 0;
			int * i_1 = &i;
			for(*i_1 = 0; i < 10; *i_1 = i + 1) {
				printf("%d\n", buffer[i]);
			}
		}
	}
	return 0;
}