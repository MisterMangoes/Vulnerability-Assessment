/*
Program description: In this program, if staticReturnsTrue() returns 1, data points to a string that consists of 42 wide characters and dest is allocated memory for 42 characters (the number of wide characters in data). Then, data is copied to dest using wcscpy() and dest is printed out

Vulnerability and consequence: However, the space allocated for dest is equal to 42 characters, but data consists of 42 wide characters. Each wide character requires a larger storage size than a standard character, so when data is copied to dest, it overwrites dest incorrectly, thus causing a stack buffer overflow

The vulnerability triggers in the following lines:
(void)wcscpy(dest, data);

Mitigation: To make this program safe to run, ensure that when allocating space for dest, treat data as a wide character string instead of a normal character string. Instead of using sizeof(char), use sizeof(wchar_t)
*/

#include <wchar.h>
#include <assert.h>

#define ALLOCA alloca

#define WIDE_STRING L"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" //42 wide characters

static int staticReturnsTrue() {
	return 1;
}

int main() {
	if(staticReturnsTrue()) {
		void * data = (void *)WIDE_STRING;
		size_t dataLen = wcslen((wchar_t *)data);
		int destMemorySize = dataLen * sizeof(char);
		void * dest = (void *)ALLOCA(destMemorySize);
		assert(destMemorySize >= dataLen * sizeof(wchar_t));
		wcscpy(dest, data);
		wprintf(L"%ls\n", dest);
	}
	return 0;
}