/*
Program description: In this program, data is allocated space for 50 wide characters by calling the function, allocatewchar(). Then, source is declared as a wide character array with size 100, which is filled with C's and the last wide character in source is assigned as a null terminate. Finally, 100 wide characters from source is appended to data using wcsncat() and data is printed out

Vulnerability and consequence: However, when using wcsncat(), the program does not check the storage size for data or how much space has already been used by data. data has a storage size for 50 wide characters, but source consists of 100 wide characters. Therefore, the program overwrites adjacent memory when data is appended to dest, which causes a heap buffer overflow

The vulnerability triggers in the following lines:
wcsncat(data, source, 100);

Mitigation: To make this program safe to run, ensure that the number of wide characters that are to be appeneded to data from source is equal to or less than the remaining space for wide characters in data when using wcsncat() so that the function does not overwrite adjacent memory
*/

#include <wchar.h>
#include <assert.h>

int dataMemorySize = 50 * sizeof(wchar_t);

int main() {
	wchar_t * data = (wchar_t *)malloc(dataMemorySize);
	data[0] = L'\0';
	wchar_t source[100];
	wmemset(source, L'C', 100-1);
	source[100-1] = L'\0';
	assert((dataMemorySize/sizeof(wchar_t) - wcslen(data)) >= 100);
	wcsncat(data, source, 100);
	free(data);
	return 0;
}